import io
import logging
import logging.handlers
import os
import sys

import dedupe
from sqlalchemy.sql import text


def get_rotating_file_handler(filepath, level=logging.INFO):
    _handler = logging.handlers.RotatingFileHandler(
        filepath, maxBytes=1000000, backupCount=10, delay=False
    )
    _formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(name)s - %(module)s.%(funcName)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    _handler.setFormatter(_formatter)
    _handler.setLevel(level)
    return _handler


def get_console_handler(level=logging.WARNING):
    _handler = logging.StreamHandler(stream=sys.stdout)
    _formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(module)s.%(funcName)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    _handler.setFormatter(_formatter)
    _handler.setLevel(level)
    return _handler


def get_console_logger(name, level="info"):
    logger = logging.getLogger(name)
    if level == "debug":
        logger.setLevel(logging.DEBUG)
    elif level == "info":
        logger.setLevel(logging.INFO)
    elif level == "warning":
        logger.setLevel(logging.WARNING)
    else:
        logger.setLevel(logging.ERROR)
    _handler = logging.StreamHandler()
    _formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(name)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    _handler.setFormatter(_formatter)
    logger.addHandler(_handler)
    logging.captureWarnings(True)
    return logger


def get_rotating_file_logger(name, filepath, level="info"):
    head, _ = os.path.split(filepath)
    os.makedirs(head, exist_ok=True)
    logger = logging.getLogger(name)
    if level == "debug":
        logger.setLevel(logging.DEBUG)
    elif level == "info":
        logger.setLevel(logging.INFO)
    elif level == "warning":
        logger.setLevel(logging.WARNING)
    else:
        logger.setLevel(logging.ERROR)
    _handler = logging.handlers.RotatingFileHandler(
        filepath, maxBytes=1000000, backupCount=10, delay=False
    )
    _formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(name)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    _handler.setFormatter(_formatter)
    logger.addHandler(_handler)
    _filter = logging.Filter("colandr")
    logger.addFilter(_filter)
    logger.propagate = False
    logging.captureWarnings(True)
    return logger


def execute_raw_sql_query(query, bindings=None, no_logging=True):
    """
    see: http://docs.sqlalchemy.org/en/latest/core/tutorial.html#specifying-bound-parameter-behaviors
    and: http://docs.sqlalchemy.org/en/latest/core/tutorial.html#using-textual-sql
    """
    from colandr import create_app, db

    bindings = bindings or {}
    if no_logging is True:  # this doesn't appear to work
        logging.getLogger("sqlalchemy.engine").setLevel(logging.CRITICAL)
    app = create_app("default")
    with app.app_context():
        conn = db.engine.connect()
        results = conn.execute(text(query), **bindings)
        for result in results:
            yield result
        results.close()


def load_dedupe_model(settings_path, num_cores=1):
    """
    Get a trained dedupe model, instantiated from settings saved to disk.

    Args:
        settings_path (str): path to file on disk where settings data is saved;
            settings files are typically generated by saving the settings
            learned from ActiveMatching
        num_cores (int): number of processes that deduper will use if able

    Returns:
        :class:``dedupe.StaticDedupe``
    """
    with io.open(settings_path, mode="rb") as f:
        deduper = dedupe.StaticDedupe(f, num_cores=num_cores)
    return deduper


def make_record_immutable(record):
    """
    Convert in-place the mutable components of ``record`` (dict) into their
    immutable analogues. (``dedupe`` only works with immutable records.)
    """
    for key, val in record.items():
        if isinstance(val, list):
            record[key] = tuple(val)
        elif isinstance(val, dict):
            record[key] = dedupe.frozendict(val)
        elif isinstance(val, set):
            record[key] = frozenset(val)
    return record
