import io
import logging
import logging.handlers

import dedupe
from sqlalchemy.sql import text


def execute_raw_sql_query(query, bindings=None, no_logging=True):
    """
    see: http://docs.sqlalchemy.org/en/latest/core/tutorial.html#specifying-bound-parameter-behaviors
    and: http://docs.sqlalchemy.org/en/latest/core/tutorial.html#using-textual-sql
    """
    # TODO: this is not great... we should fix
    from colandr.app import create_app
    from colandr.extensions import db

    bindings = bindings or {}
    if no_logging is True:  # this doesn't appear to work
        logging.getLogger("sqlalchemy.engine").setLevel(logging.CRITICAL)
    app = create_app("default")
    with app.app_context():
        conn = db.engine.connect()
        results = conn.execute(text(query), **bindings)
        for result in results:
            yield result
        results.close()


def load_dedupe_model(settings_path: str, num_cores: int = 1) -> dedupe.StaticDedupe:
    """
    Get a trained dedupe model, instantiated from settings saved to disk.

    Args:
        settings_path: path to file on disk where settings data is saved;
            settings files are typically generated by saving the settings
            learned from ActiveMatching
        num_cores: number of processes that deduper will use if able

    Returns:
        initialized StaticDedupe model
    """
    with io.open(settings_path, mode="rb") as f:
        deduper = dedupe.StaticDedupe(f, num_cores=num_cores)
    return deduper


def make_record_immutable(record: dict) -> dict:
    """
    Convert in-place the mutable components of ``record`` (dict) into their
    immutable analogues. (``dedupe`` only works with immutable records.)
    """
    for key, val in record.items():
        if isinstance(val, list):
            record[key] = tuple(val)
        elif isinstance(val, dict):
            record[key] = dedupe.frozendict(val)
        elif isinstance(val, set):
            record[key] = frozenset(val)
    return record
